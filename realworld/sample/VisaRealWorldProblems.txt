1. Array Grouping Problem

Problem:
You have an integer array. Partition it into two lists:

List A: even numbers in ascending order

List B: odd numbers in descending order
Then combine them with all elements of List A first, then List B.

*********************************************************************

2. Queue ID-Check Timing Problem

Problem:
At a security gate:

Check takes 5 minutes per person.

Queue can have max length maxQueueLen.

Given arrival times (minutes after opening), find the time last person enters.

Restating the Problem

We have:

Arrival times (in minutes from the gate opening).
Security check takes 5 minutes per person.
The queue can only hold maxQueueLen people at any time (including the one being checked).
People arrive in order given by the array.
If a person arrives and the queue is full, they must wait until a spot is free (i.e., the check finishes for someone).

We need to find:
The time (in minutes) when the last person finishes entering.

Example 1

Input:

arrivals = [0, 0, 3, 5, 9, 10]
maxQueueLen = 3

Check takes 5 minutes per person.


Step-by-step Simulation - below is for person finish time
Time 0:

Person1 arrives (queue: 1) ✅ enters queue

Person2 arrives (queue: 2) ✅ enters queue

Start processing Person1 (takes until 5).

Time 3:

Person3 arrives (queue: 3) ✅ enters queue

Queue now full.

Time 5:

Person1 done ✅ queue size: 2

Person4 arrives at time 5 (queue: 3) ✅ enters queue

Start processing Person2 (will finish at 10).

Time 9:

Person5 arrives (queue: FULL = 3) ❌ must wait
They wait until time 10 when Person2 finishes.

Time 10:

Person2 done ✅ queue size: 2

Person5 joins queue (size now 3)

Start processing Person3 (finishes at 15).

Time 10:

Person6 arrives at time 10, but queue is full. ❌ must wait until time 15.

Time 15:

Person3 done ✅ queue size: 2

Person6 joins queue (size now 3)

Start processing Person4 (finishes at 20).

Time 20:

Person4 done ✅ queue size: 2

Start processing Person5 (finishes at 25).

Time 25:

Person5 done ✅ queue size: 1

Start processing Person6 (finishes at 30).

Time 30:

Person6 done — last person done at 30 minutes.

✅ Output: 30

*********************************************************************

3. One-Swap Pairs Problem

Problem:
You are given two equal-length arrays A and B.
Count how many pairs (i, j) need at most one swap of elements in A to match B.

Problem Recap

Given:

Two arrays A and B of equal length.

Task:

Count how many elements in A can match B after at most one swap of two elements in A.

Rules:

A single swap can exchange any two elements in A.

You want to maximize the number of positions where A[i] == B[i] after at most one swap.

Count all elements that would match after this swap.

Key Notes

0 mismatches → arrays already match → no swap needed.
2 mismatches → one swap can fix all mismatches.
>2 mismatches → one swap cannot fix all → only already matched positions count.


Step-by-Step Approach

Step 1: Identify mismatches

Compare A[i] and B[i].

If they are equal → already matched.

If they are different → candidate for swap.

Step 2: Determine if one swap fixes mismatches

If 0 mismatches → arrays already match → all elements match.

If 2 mismatches → swapping the mismatched elements in A might make them match → all elements match.

If more than 2 mismatches → one swap cannot fix all → only the positions that already match count.

Step 3: Count matching positions

Let mismatchCount = number of positions where A[i] != B[i].

Return:

A.length if mismatchCount == 0 or mismatchCount == 2 (swap fixes everything)

A.length - mismatchCount otherwise (only already matched positions count)

EXAMPLES:

Example 1
A = [1, 3, 5, 7]
B = [1, 5, 3, 7]

Step 1: Compare elements

| i | A\[i] | B\[i] | Match? |
| - | ----- | ----- | ------ |
| 0 | 1     | 1     | ✅      |
| 1 | 3     | 5     | ❌      |
| 2 | 5     | 3     | ❌      |
| 3 | 7     | 7     | ✅      |


Mismatches = 2 → positions 1 and 2

Step 2: Check swap possibility

Swap A[1] and A[2] → A becomes [1, 5, 3, 7]

Now all positions match

Step 3: Count

Total matching after swap = 4

✅ Answer: 4


Example 2
A = [1, 2, 3, 4]
B = [1, 4, 3, 2]

Step 1: Compare elements

| i | A\[i] | B\[i] | Match? |
| - | ----- | ----- | ------ |
| 0 | 1     | 1     | ✅      |
| 1 | 2     | 4     | ❌      |
| 2 | 3     | 3     | ✅      |
| 3 | 4     | 2     | ❌      |


Mismatches = 2 → positions 1 and 3

Step 2: Swap check

Swap A[1] and A[3] → A becomes [1, 4, 3, 2]

Now all positions match

Step 3: Count

Total matching = 4

✅ Answer: 4

Example 3
A = [1, 2, 3, 4, 5]
B = [5, 4, 3, 2, 1]

Step 1: Compare elements

| i | A\[i] | B\[i] | Match? |
| - | ----- | ----- | ------ |
| 0 | 1     | 5     | ❌      |
| 1 | 2     | 4     | ❌      |
| 2 | 3     | 3     | ✅      |
| 3 | 4     | 2     | ❌      |
| 4 | 5     | 1     | ❌      |

Mismatches = 4 → positions 0,1,3,4

Step 2: Swap check

Only one swap allowed → cannot fix all mismatches

Step 3: Count

Only positions already matching = position 2 → 1 element

✅ Answer: 1
